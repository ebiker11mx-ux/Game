<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Obby Foundation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    :root {
      --bg: #0f1226;
      --ui: #1f2347;
      --accent: #5ee6ff;
      --accent2: #ff7a7a;
      --text: #e9f0ff;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #game-wrap { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; }

    /* HUD */
    #hud {
      position: absolute; inset: 0; pointer-events: none;
      display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: auto 1fr auto; padding: 10px;
    }
    #top-bar {
      grid-column: 1 / -1; display: flex; align-items: center; gap: 8px; padding: 8px 10px;
      background: rgba(31,35,71,0.7); border-radius: 10px; backdrop-filter: blur(6px); pointer-events: auto;
    }
    .pill {
      padding: 6px 10px; border-radius: 999px; background: rgba(94,230,255,0.15); border: 1px solid rgba(94,230,255,0.4); color: var(--accent);
      font-size: 12px; white-space: nowrap;
    }
    #title { font-weight: 700; letter-spacing: 0.5px; }

    /* Controls */
    #controls {
      grid-column: 1 / -1; grid-row: 3; display: flex; justify-content: space-between; align-items: end; padding: 10px;
      pointer-events: auto;
    }
    .joystick {
      position: relative; width: 140px; height: 140px; border-radius: 50%;
      background: rgba(31,35,71,0.65); border: 1px solid rgba(94,230,255,0.25); backdrop-filter: blur(6px);
      touch-action: none;
    }
    .stick {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
      width: 64px; height: 64px; border-radius: 50%; background: rgba(94,230,255,0.35); border: 2px solid rgba(94,230,255,0.7);
    }
    .button {
      min-width: 120px; height: 120px; border-radius: 18px; background: linear-gradient(180deg, #2b3063, #1f2347);
      border: 2px solid rgba(194,139,255,0.4); color: var(--text); font-weight: 700; display: grid; place-items: center;
      box-shadow: 0 8px 16px rgba(0,0,0,0.35); touch-action: none;
    }
    .button:active { transform: translateY(2px); }

    /* Pause menu + center message */
    #menu {
      position: absolute; right: 10px; top: 60px; padding: 10px; border-radius: 10px;
      background: rgba(31,35,71,0.8); border: 1px solid rgba(94,230,255,0.25); backdrop-filter: blur(6px);
      display: none; flex-direction: column; gap: 8px; pointer-events: auto; z-index: 5;
    }
    #menu button {
      all: unset; padding: 8px 10px; border-radius: 8px; background: rgba(94,230,255,0.15);
      border: 1px solid rgba(94,230,255,0.35); color: var(--text); text-align: center; font-weight: 600; cursor: pointer;
    }
    #menu button.danger { background: rgba(255,122,122,0.15); border-color: rgba(255,122,122,0.45); }
    #center-msg {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
      padding: 12px 18px; border-radius: 12px; background: rgba(31,35,71,0.75); border: 1px solid rgba(94,230,255,0.3);
      backdrop-filter: blur(6px); text-align: center; pointer-events: none; display: none;
    }
  </style>
</head>
<body>
  <div id="game-wrap">
    <canvas id="canvas"></canvas>
    <div id="hud">
      <div id="top-bar">
        <div id="title">Obby Foundation 3D</div>
        <div class="pill" id="level-pill">Level 1</div>
        <div class="pill" id="timer">00:00</div>
        <div style="margin-left:auto;">
          <button id="pause" class="pill" style="cursor:pointer; pointer-events:auto;">Pause</button>
        </div>
      </div>
      <div id="controls">
        <div id="joystick" class="joystick"><div class="stick"></div></div>
        <button id="jump" class="button">Jump</button>
      </div>
    </div>
    <div id="center-msg"></div>
    <div id="menu">
      <button id="resume">Resume</button>
      <button id="restart">Restart from Start</button>
      <button id="checkpoint">Respawn at Checkpoint</button>
      <button id="quit" class="danger">Quit</button>
    </div>
  </div>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
    // Utils ---------------------------------------------------------------
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    function formatTime(ms) {
      const s = Math.floor(ms / 1000); const m = Math.floor(s / 60); const r = s % 60;
      return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`;
    }

    // Input ---------------------------------------------------------------
    class Input {
      constructor(joyEl, jumpEl) {
        this.dir = { x: 0, y: 0 }; // x: left/right, y unused (forward/back optional)
        this.jumpPressed = false;
        this.jumpHeld = false;

        const stick = joyEl.querySelector('.stick');
        const radius = joyEl.clientWidth / 2;
        const center = { x: joyEl.clientWidth/2, y: joyEl.clientHeight/2 };
        const toLocal = (e) => {
          const rect = joyEl.getBoundingClientRect();
          const x = (e.touches? e.touches[0].clientX : e.clientX) - rect.left;
          const y = (e.touches? e.touches[0].clientY : e.clientY) - rect.top;
          return { x, y };
        };
        const setStick = (p) => {
          const dx = p.x - center.x, dy = p.y - center.y;
          const mag = Math.hypot(dx, dy);
          const max = radius - 28;
          const scale = mag > 0 ? Math.min(1, mag / max) : 0;
          this.dir.x = (dx / max) * scale; // horizontal only
          const sx = clamp(dx, -max, max);
          const sy = clamp(dy, -max, max);
          stick.style.transform = `translate(${sx}px, ${sy}px) translate(-50%, -50%)`;
        };
        const resetStick = () => { this.dir.x = 0; stick.style.transform = 'translate(-50%, -50%)'; };

        joyEl.addEventListener('touchstart', (e)=>{ e.preventDefault(); setStick(toLocal(e)); });
        joyEl.addEventListener('touchmove',  (e)=>{ e.preventDefault(); setStick(toLocal(e)); });
        joyEl.addEventListener('touchend',   (e)=>{ e.preventDefault(); resetStick(); });
        joyEl.addEventListener('mousedown',  (e)=>{ e.preventDefault(); setStick(toLocal(e)); });
        window.addEventListener('mousemove', (e)=>{ if (e.buttons & 1) setStick(toLocal(e)); });
        window.addEventListener('mouseup',   ()=> resetStick());

        jumpEl.addEventListener('touchstart', (e)=>{ e.preventDefault(); this.jumpPressed = true; this.jumpHeld = true; });
        jumpEl.addEventListener('touchend',   (e)=>{ e.preventDefault(); this.jumpHeld = false; });
        jumpEl.addEventListener('mousedown',  (e)=>{ e.preventDefault(); this.jumpPressed = true; this.jumpHeld = true; });
        jumpEl.addEventListener('mouseup',    (e)=>{ e.preventDefault(); this.jumpHeld = false; });

        window.addEventListener('keydown', (e)=>{
          if (e.code === 'Space' || e.code === 'ArrowUp') { this.jumpPressed = true; this.jumpHeld = true; }
          if (e.code === 'ArrowLeft' || e.code === 'KeyA') { this.dir.x = -1; }
          if (e.code === 'ArrowRight' || e.code === 'KeyD') { this.dir.x = 1; }
        });
        window.addEventListener('keyup', (e)=>{
          if (e.code === 'Space' || e.code === 'ArrowUp') { this.jumpHeld = false; }
          if (['ArrowLeft','KeyA','ArrowRight','KeyD'].includes(e.code)) { this.dir.x = 0; }
        });
      }
      consumeJump(){ const p = this.jumpPressed; this.jumpPressed = false; return p; }
    }

    // Geometry helpers ---------------------------------------------------
    function makeBox(w, h, d, color) {
      const geo = new THREE.BoxGeometry(w, h, d);
      const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.6, metalness: 0.0 });
      const m = new THREE.Mesh(geo, mat);
      m.castShadow = true; m.receiveShadow = true;
      return m;
    }
    function makeCylinder(r, h, color) {
      const geo = new THREE.CylinderGeometry(r, r, h, 24);
      const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.6, metalness: 0.0 });
      const m = new THREE.Mesh(geo, mat);
      m.castShadow = true; m.receiveShadow = true;
      return m;
    }

    // Axis-aligned bounding box (AABB) in XZ with Y for height -----------
    function aabbIntersect(a, b) {
      return !(a.max.x < b.min.x || a.min.x > b.max.x || a.max.y < b.min.y || a.min.y > b.max.y || a.max.z < b.min.z || a.min.z > b.max.z);
    }
    function getWorldAABB(mesh) {
      mesh.updateMatrixWorld();
      const box = new THREE.Box3().setFromObject(mesh);
      return box;
    }

    // Player --------------------------------------------------------------
    class Player {
      constructor(scene, spawn) {
        this.size = { w: 0.8, h: 1.6, d: 0.8 };
        // Capsule-like: cylinder + sphere top
        this.mesh = makeCylinder(0.4, 1.2, 0x5ee6ff);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.45, 20, 16), new THREE.MeshStandardMaterial({ color: 0x5ee6ff }));
        head.position.y = 0.9;
        const group = new THREE.Group();
        group.add(this.mesh); group.add(head);
        group.castShadow = true; group.receiveShadow = false;
        scene.add(group);
        this.group = group;

        this.pos = new THREE.Vector3(spawn.x, spawn.y, spawn.z);
        this.vel = new THREE.Vector3(0, 0, 0);
        this.onGround = false;
        this.dead = false;
        this.checkpoint = this.pos.clone();
        this._spawn = this.pos.clone();

        // Tunables
        this.maxSpeed = 6.0;
        this.accel = 30.0;
        this.friction = 24.0;
        this.jumpSpeed = 8.5;
        this.gravity = 24.0;
        this.coyoteTime = 0.12;
        this.jumpBuffer = 0.12;
        this._coyoteT = 0;
        this._jumpBufT = 0;
      }
      setSpawn(spawn){ this._spawn.copy(spawn); this.respawn(false); }
      respawn(useCheckpoint=false) {
        const p = useCheckpoint ? this.checkpoint : this._spawn;
        this.pos.copy(p); this.vel.set(0,0,0); this.onGround=false; this.dead=false;
      }
      update(dt, input, solids, specials) {
        // Horizontal movement along X; Z fixed path (can extend later)
        const targetX = input.dir.x * this.maxSpeed;
        const deltaX = targetX - this.vel.x;
        const accel = Math.sign(deltaX) * this.accel * dt;
        if (Math.abs(deltaX) < Math.abs(accel)) this.vel.x = targetX; else this.vel.x += accel;
        if (Math.abs(input.dir.x) < 0.05) {
          const fric = Math.min(Math.abs(this.vel.x), this.friction * dt);
          this.vel.x -= Math.sign(this.vel.x) * fric;
        }

        // Gravity
        this.vel.y -= this.gravity * dt;

        // Jump buffering + coyote
        if (input.consumeJump()) this._jumpBufT = this.jumpBuffer;
        this._coyoteT = this.onGround ? this.coyoteTime : Math.max(0, this._coyoteT - dt);
        this._jumpBufT = Math.max(0, this._jumpBufT - dt);
        if (this._jumpBufT > 0 && (this.onGround || this._coyoteT > 0)) {
          this.vel.y = this.jumpSpeed;
          this.onGround = false; this._coyoteT = 0; this._jumpBufT = 0;
        }

        // Integrate
        const next = this.pos.clone().addScaledVector(this.vel, dt);

        // Collision against solids (platform tops)
        // Simple approach: detect overlap with platform boxes and resolve Y if falling onto them
        let grounded = false;
        // Temporarily move group to next to compute collisions
        const tempPos = next.clone();
        this.group.position.set(tempPos.x, tempPos.y, tempPos.z);
        const playerBox = getWorldAABB(this.group);

        for (const s of solids) {
          const box = getWorldAABB(s.mesh);
          if (aabbIntersect(playerBox, box)) {
            // Check vertical resolution: if player is above platform and descending, snap to top
            const topY = box.max.y;
            const bottomY = box.min.y;
            const wasAbove = (this.pos.y >= topY - 0.2);
            if (wasAbove && this.vel.y <= 0) {
              // Land on platform
              next.y = topY + 0.01;
              this.vel.y = Math.max(this.vel.y, 0);
              grounded = true;

              // Moving/rotating platforms can impart motion:
              if (s.type === 'move' && s.moveAxis) {
                if (s.moveAxis === 'x') next.x += s.speed * dt;
                if (s.moveAxis === 'z') next.z += s.speed * dt;
              }
              if (s.type === 'rotator' && s.pivot) {
                // apply a tiny tangential nudge if desired (optional)
              }
            } else {
              // Side collision: push out in X to avoid clipping
              const dxLeft = Math.abs(playerBox.max.x - box.min.x);
              const dxRight = Math.abs(box.max.x - playerBox.min.x);
              if (dxLeft < dxRight) next.x = box.min.x - (playerBox.max.x - playerBox.min.x)/2 - 0.02;
              else next.x = box.max.x + (playerBox.max.x - playerBox.min.x)/2 + 0.02;
              this.vel.x = 0;
            }
            // Recompute playerBox for subsequent collisions
            this.group.position.set(next.x, next.y, next.z);
            Object.assign(playerBox, getWorldAABB(this.group));
          }
        }

        // Specials
        for (const sp of specials) {
          const box = getWorldAABB(sp.mesh || sp);
          if (aabbIntersect(playerBox, box)) {
            if (sp.type === 'kill') {
              this.dead = true;
            }
            if (sp.type === 'checkpoint') {
              this.checkpoint.set(next.x, box.max.y + 0.01, next.z);
            }
            if (sp.type === 'finish') {
              sp._win = true;
            }
          }
        }

        // Commit
        this.onGround = grounded;
        this.pos.copy(next);
        this.group.position.set(this.pos.x, this.pos.y, this.pos.z);
      }
    }

    // Platform classes ---------------------------------------------------
    class Platform {
      constructor(mesh, type='static') {
        this.mesh = mesh; this.type = type;
        this.speed = 0; this.moveAxis = null; this.pivot = null;
      }
      setPosition(x,y,z){ this.mesh.position.set(x,y,z); return this; }
      setMove(axis, min, max, speed) {
        this.moveAxis = axis; this.min = min; this.max = max; this.speed = speed; return this;
      }
      setRotator(pivot, axis='y', speed=1.0) {
        this.pivot = pivot.clone(); this.rotAxis = axis; this.rotSpeed = speed; return this;
      }
      update(dt) {
        if (this.moveAxis) {
          const pos = this.mesh.position[this.moveAxis];
          const next = pos + this.speed * dt;
          const size = 0;
          if (next < this.min || next > this.max) {
            this.speed *= -1;
          }
          this.mesh.position[this.moveAxis] += this.speed * dt;
        }
        if (this.pivot) {
          // rotate around pivot by applying rotation
          const m = this.mesh;
          const axis = new THREE.Vector3(
            this.rotAxis === 'x' ? 1 : 0,
            this.rotAxis === 'y' ? 1 : 0,
            this.rotAxis === 'z' ? 1 : 0
          );
          // rotate around pivot: translate to origin, rotate, translate back
          const pos = m.position.clone().sub(this.pivot);
          const angle = this.rotSpeed * dt;
          const q = new THREE.Quaternion().setFromAxisAngle(axis, angle);
          pos.applyQuaternion(q);
          m.position.copy(pos.add(this.pivot));
          m.rotateOnAxis(axis, angle);
        }
      }
    }

    // Level builder ------------------------------------------------------
    function buildLevel1(scene) {
      const solids = [];
      const specials = [];

      // Ground (visual only, not for landing)
      const floor = makeBox(200, 1, 200, 0x1f2347);
      floor.position.set(0, -10, 0);
      floor.receiveShadow = true;
      scene.add(floor);

      // Start pad
      const start = new Platform(makeBox(6, 0.6, 3, 0x8ac5ff), 'static').setPosition(-10, 0, 0);
      solids.push(start);

      // Zigzag path (precision)
      for (let i = 0; i < 8; i++) {
        const dx = i * 3.2;
        const dz = (i % 2 === 0) ? 0 : 1.2;
        const p = new Platform(makeBox(2.2, 0.4, 1.2, 0xff7a7a), 'static').setPosition(-2 + dx, 1.5, dz);
        solids.push(p);
      }

      // Rotating beam corridor
      // Pivot pillars
      const pivotLeft = new THREE.Vector3(26, 2.0, -1.5);
      const pivotRight = new THREE.Vector3(26, 2.0, 1.5);
      const pillarL = makeCylinder(0.25, 2.5, 0x8888ff); pillarL.position.copy(pivotLeft); scene.add(pillarL);
      const pillarR = makeCylinder(0.25, 2.5, 0x8888ff); pillarR.position.copy(pivotRight); scene.add(pillarR);

      // Horizontal beams attached to pivots (two heights)
      const beam1 = new Platform(makeBox(8, 0.3, 0.4, 0xffd580), 'rotator').setPosition(pivotLeft.x + 4, pivotLeft.y, pivotLeft.z);
      beam1.setRotator(pivotLeft, 'y', 1.2);
      solids.push(beam1);

      const beam2 = new Platform(makeBox(8, 0.3, 0.4, 0xffd580), 'rotator').setPosition(pivotRight.x - 4, pivotRight.y + 0.6, pivotRight.z);
      beam2.setRotator(pivotRight, 'y', -1.4);
      solids.push(beam2);

      // Static stepping platforms around rotators
      solids.push(new Platform(makeBox(2.5, 0.4, 1.2, 0x8ac5ff), 'static').setPosition(20, 1.5, 0));
      solids.push(new Platform(makeBox(2.5, 0.4, 1.2, 0x8ac5ff), 'static').setPosition(30, 1.5, 0));

      // Moving elevator to checkpoint
      const elevator = new Platform(makeBox(2.4, 0.4, 1.6, 0x66e08a), 'move').setPosition(36, 1.0, 0);
      elevator.setMove('y', 0.8, 3.2, 1.2);
      solids.push(elevator);

      // Checkpoint platform
      const checkpoint = makeBox(2.8, 0.4, 1.6, 0x66e08a); checkpoint.position.set(40, 3.2, 0); scene.add(checkpoint);
      specials.push({ type: 'checkpoint', mesh: checkpoint });

      // Kill pit (visual)
      const killPit = makeBox(14, 0.2, 4, 0xff6b6b); killPit.position.set(48, -2.5, 0); scene.add(killPit);
      specials.push({ type: 'kill', mesh: killPit });

      // Narrow path to finish
      solids.push(new Platform(makeBox(2.0, 0.4, 1.2, 0x8ac5ff), 'static').setPosition(52, 1.8, 0));
      solids.push(new Platform(makeBox(2.0, 0.4, 1.2, 0x8ac5ff), 'static').setPosition(55, 1.8, 0));

      // Finish pad
      const finish = makeBox(3.0, 0.4, 2.0, 0xc28bff); finish.position.set(59, 1.8, 0); scene.add(finish);
      specials.push({ type: 'finish', mesh: finish });

      return {
        spawn: new THREE.Vector3(-10, 2.2, 0),
        solids,
        specials,
        name: 'Level 1'
      };
    }

    function buildLevel2(scene) {
      const solids = [];
      const specials = [];

      // Start
      const start = new Platform(makeBox(6, 0.6, 3, 0x8ac5ff), 'static').setPosition(-6, 0, 0);
      solids.push(start);

      // Rhythm moving platforms
      const m1 = new Platform(makeBox(2.6, 0.4, 1.2, 0xffd580), 'move').setPosition(2, 1.2, 0); m1.setMove('x', -2, 6, 2.4); solids.push(m1);
      const m2 = new Platform(makeBox(2.6, 0.4, 1.2, 0xffd580), 'move').setPosition(10, 1.6, 0); m2.setMove('x', 6, 14, -2.8); solids.push(m2);
      const m3 = new Platform(makeBox(2.6, 0.4, 1.2, 0xffd580), 'move').setPosition(18, 2.0, 0); m3.setMove('x', 14, 22, 3.0); solids.push(m3);

      // Kill zone below
      const killPit = makeBox(20, 0.2, 4, 0xff6b6b); killPit.position.set(10, -2.5, 0); scene.add(killPit);
      specials.push({ type: 'kill', mesh: killPit });

      // Tight path and finish
      solids.push(new Platform(makeBox(2.0, 0.4, 1.0, 0x8ac5ff), 'static').setPosition(24, 2.2, 0));
      solids.push(new Platform(makeBox(2.0, 0.4, 1.0, 0x8ac5ff), 'static').setPosition(27, 2.4, 0));
      const finish =
