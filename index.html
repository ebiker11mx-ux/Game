<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Obstacle Course</title>
<style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
    }
    button {
        padding: 20px;
        font-size: 18px;
        border-radius: 50%;
        background-color: rgba(0,0,0,0.5);
        color: white;
        border: none;
    }
</style>
</head>
<body>
<div id="controls">
    <button id="jumpBtn">Jump</button>
    <button id="doubleJumpBtn">Double Jump</button>
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/controls/PointerLockControls.js"></script>
<script>
    let scene, camera, renderer, player, controls;
    let obstacles = [], checkpoints = [];
    let speed = 0.1;
    let jumpVelocity = 0;
    let canDoubleJump = true;
    let gravity = 0.01;
    let lastCheckpoint = new THREE.Vector3(0, 1, 0);

    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 5);

        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5,10,7);
        scene.add(light);

        // Player
        player = new THREE.Mesh(
            new THREE.BoxGeometry(1,1,1),
            new THREE.MeshStandardMaterial({color:0xff0000})
        );
        player.position.set(0,1,0);
        scene.add(player);

        // Ground
        addObstacle(0, 0, -5, 10, 1, 10); // start platform

        // Create obstacle course
        for(let i=0; i<20; i++){
            let size = 2 + Math.random()*2;
            let x = (Math.random()-0.5) * 6;
            let y = 0;
            let z = -10 - i*5;
            addObstacle(x,y,z,size,1,size);

            // Add checkpoint every 3 blocks
            if(i % 3 === 0){
                let cp = new THREE.Mesh(
                    new THREE.BoxGeometry(1,1,1),
                    new THREE.MeshStandardMaterial({color:0x00ff00})
                );
                cp.position.set(x,2,z);
                scene.add(cp);
                checkpoints.push(cp);
            }
        }

        window.addEventListener('resize', onWindowResize, false);

        // Controls
        document.getElementById('jumpBtn').addEventListener('click', () => jump(false));
        document.getElementById('doubleJumpBtn').addEventListener('click', () => jump(true));
    }

    function addObstacle(x,y,z,w,h,d){
        let geometry = new THREE.BoxGeometry(w,h,d);
        let material = new THREE.MeshStandardMaterial({color:0x808080});
        let cube = new THREE.Mesh(geometry, material);
        cube.position.set(x, y, z);
        scene.add(cube);
        obstacles.push(cube);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function jump(doubleJump){
        if(doubleJump && canDoubleJump){
            jumpVelocity = 0.2;
            canDoubleJump = false;
        } else if(!doubleJump && player.position.y <= 1.01){
            jumpVelocity = 0.2;
        }
    }

    function checkCollision(){
        let onGround = false;
        for(let obs of obstacles){
            if(
                player.position.x + 0.5 > obs.position.x - obs.scale.x/2 &&
                player.position.x - 0.5 < obs.position.x + obs.scale.x/2 &&
                player.position.y - 0.5 <= obs.position.y + obs.scale.y/2 &&
                player.position.y - 0.5 > obs.position.y &&
                player.position.z + 0.5 > obs.position.z - obs.scale.z/2 &&
                player.position.z - 0.5 < obs.position.z + obs.scale.z/2
            ){
                player.position.y = obs.position.y + 1;
                jumpVelocity = 0;
                canDoubleJump = true;
                onGround = true;
            }
        }
        return onGround;
    }

    function checkCheckpoint(){
        for(let cp of checkpoints){
            if(player.position.distanceTo(cp.position) < 1){
                lastCheckpoint.copy(cp.position);
                lastCheckpoint.y = 1;
            }
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        // Move forward automatically
        player.position.z -= speed;

        // Gravity
        jumpVelocity -= gravity;
        player.position.y += jumpVelocity;

        // Collision
        let onGround = checkCollision();
        if(onGround && jumpVelocity < 0) jumpVelocity = 0;

        // Checkpoint
        checkCheckpoint();

        // Respawn if fall
        if(player.position.y < -5){
            player.position.copy(lastCheckpoint);
            jumpVelocity = 0;
        }

        // Camera follows player
        camera.position.lerp(new THREE.Vector3(player.position.x, player.position.y + 3, player.position.z + 5),0.1);
        camera.lookAt(player.position);

        renderer.render(scene, camera);
    }
</script>
</body>
</html>
