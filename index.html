<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no" />
  <title>Mobile Obstacle Course – Improved</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #2c2f4a, #0f1020);
      font-family: system-ui, sans-serif;
    }canvas { display: block; }

#hud {
  position: absolute;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);
  color: #fff;
  font-size: 16px;
  padding: 8px 14px;
  background: rgba(0,0,0,0.35);
  border-radius: 12px;
  backdrop-filter: blur(6px);
}

.controls {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 14px;
}

.controls button {
  width: 64px;
  height: 64px;
  font-size: 22px;
  border-radius: 50%;
  border: none;
  background: linear-gradient(145deg, #3aa4ff, #1f6fd1);
  color: #fff;
  box-shadow: 0 6px 14px rgba(0,0,0,0.4);
  touch-action: none;
}

.controls button:active {
  transform: scale(0.95);
}

  </style>
</head>
<body><div id="hud">Level 1 · Checkpoint 1</div><div class="controls">
  <button id="left">⬅</button>
  <button id="jump">⬆</button>
  <button id="right">➡</button>
</div><script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script><script>
/* ======================================================
   CORE SETUP
====================================================== */
let scene, camera, renderer;
let player, shadow;
let platforms = [], movingPlatforms = [], checkpoints = [];
let velocity = new THREE.Vector3();
let move = { left:false, right:false };

let gravity = 0.012;
let speed = 0.09;
let jumpPower = 0.22;
let canJump = false;

let level = 1;
let checkpointIndex = 0;

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0f1020, 15, 60);

  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 200);
  camera.position.set(0, 6, 10);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // Lighting
  scene.add(new THREE.AmbientLight(0x8899ff, 0.35));

  const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
  dirLight.position.set(5, 15, 5);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.set(1024, 1024);
  scene.add(dirLight);

  // Ground
  addPlatform(0, -0.5, 0, 60, 1, 60, 0x1c2540, false, true);

  // Player
  const geo = new THREE.SphereGeometry(0.45, 24, 24);
  const mat = new THREE.MeshStandardMaterial({
    color: 0xff5c5c,
    roughness: 0.4,
    metalness: 0.1
  });
  player = new THREE.Mesh(geo, mat);
  player.castShadow = true;
  player.position.set(0, 0.5, 0);
  scene.add(player);

  // Simple fake shadow
  const shadowGeo = new THREE.CircleGeometry(0.5, 24);
  const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true });
  shadow = new THREE.Mesh(shadowGeo, shadowMat);
  shadow.rotation.x = -Math.PI / 2;
  scene.add(shadow);

  setupControls();
  loadLevel(level);

  window.addEventListener('resize', onResize);
}

/* ======================================================
   OBJECT HELPERS
====================================================== */
function addPlatform(x, y, z, w=3, h=0.5, d=3, color=0x3aa4ff, moving=false, isGround=false) {
  const geo = new THREE.BoxGeometry(w, h, d);
  const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y + h / 2, z);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  mesh.userData = {
    w, h, d,
    moving,
    isGround,
    startX: x,
    dir: 1
  };
  scene.add(mesh);
  platforms.push(mesh);
  if (moving) movingPlatforms.push(mesh);
}

function addCheckpoint(x, y, z) {
  const geo = new THREE.TorusGeometry(0.45, 0.15, 12, 20);
  const mat = new THREE.MeshStandardMaterial({ color: 0x2ecc71, emissive: 0x1d6b44 });
  const cp = new THREE.Mesh(geo, mat);
  cp.position.set(x, y + 0.7, z);
  cp.rotation.x = Math.PI / 2;
  scene.add(cp);
  checkpoints.push(cp);
}

/* ======================================================
   CONTROLS
====================================================== */
function setupControls() {
  const left = document.getElementById('left');
  const right = document.getElementById('right');
  const jump = document.getElementById('jump');

  left.addEventListener('touchstart', () => move.left = true);
  left.addEventListener('touchend', () => move.left = false);

  right.addEventListener('touchstart', () => move.right = true);
  right.addEventListener('touchend', () => move.right = false);

  jump.addEventListener('touchstart', () => {
    if (canJump) {
      velocity.y = jumpPower;
      canJump = false;
    }
  });
}

/* ======================================================
   LEVELS
====================================================== */
function loadLevel(n) {
  platforms.forEach(p => !p.userData.isGround && scene.remove(p));
  checkpoints.forEach(c => scene.remove(c));
  platforms = platforms.filter(p => p.userData.isGround);
  movingPlatforms = [];
  checkpoints = [];
  checkpointIndex = 0;

  if (n === 1) {
    for (let i = 0; i < 6; i++) {
      addPlatform(i * 4 - 8, i * 1.2, -i * 3);
      if (i === 2 || i === 5) addCheckpoint(i * 4 - 8, i * 1.2, -i * 3);
    }
  }

  if (n === 2) {
    for (let i = 0; i < 8; i++) {
      addPlatform(i * 4 - 12, 1 + Math.sin(i) * 1.4, -i * 3, 3, 0.5, 3, 0x3aa4ff, i % 2 === 0);
      if (i === 3 || i === 7) addCheckpoint(i * 4 - 12, 1 + Math.sin(i) * 1.4, -i * 3);
    }
  }

  updateHUD();
}

/* ======================================================
   HUD
====================================================== */
function updateHUD() {
  document.getElementById('hud').textContent = `Level ${level} · Checkpoint ${checkpointIndex + 1}`;
}

/* ======================================================
   GAME LOOP
====================================================== */
function animate() {
  requestAnimationFrame(animate);

  // Moving platforms
  movingPlatforms.forEach(p => {
    p.position.x += 0.03 * p.userData.dir;
    if (Math.abs(p.position.x - p.userData.startX) > 2) p.userData.dir *= -1;
  });

  // Movement
  if (move.left) player.position.x -= speed;
  if (move.right) player.position.x += speed;

  velocity.y -= gravity;
  player.position.y += velocity.y;

  canJump = false;

  // Collisions
  platforms.forEach(p => {
    const { w, h, d } = p.userData;
    const px = player.position.x;
    const py = player.position.y - 0.45;
    const pz = player.position.z;

    if (
      px > p.position.x - w / 2 && px < p.position.x + w / 2 &&
      pz > p.position.z - d / 2 && pz < p.position.z + d / 2 &&
      py <= p.position.y + h / 2 && py >= p.position.y - h / 2 &&
      velocity.y <= 0
    ) {
      player.position.y = p.position.y + h / 2 + 0.45;
      velocity.y = 0;
      canJump = true;
    }
  });

  // Checkpoints
  checkpoints.forEach((c, i) => {
    if (player.position.distanceTo(c.position) < 0.9) {
      checkpointIndex = i;
      updateHUD();
    }
  });

  // Fall reset
  if (player.position.y < -10) {
    if (checkpoints[checkpointIndex]) {
      player.position.copy(checkpoints[checkpointIndex].position);
      player.position.y += 1;
    } else {
      player.position.set(0, 0.5, 0);
    }
    velocity.set(0, 0, 0);
  }

  // Level complete
  if (checkpointIndex === checkpoints.length - 1 && checkpoints.length > 0) {
    level++;
    loadLevel(level);
    player.position.set(0, 0.5, 0);
    velocity.set(0, 0, 0);
  }

  // Camera follow
  camera.position.lerp(
    new THREE.Vector3(player.position.x, player.position.y + 6, player.position.z + 10),
    0.08
  );
  camera.lookAt(player.position);

  // Fake shadow follow
  shadow.position.set(player.position.x, 0.01, player.position.z);
  shadow.scale.setScalar(1 + Math.max(0, -velocity.y * 5));

  renderer.render(scene, camera);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script></body>
</html>
