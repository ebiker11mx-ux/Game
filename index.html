<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no">
<title>Mobile Obstacle Course Game</title>
<style>
  body, html { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#202033; }
  canvas { display:block; }
  .controls { position:absolute; bottom:20px; left:50%; transform:translateX(-50%); display:flex; gap:10px; }
  .controls button { font-size:18px; padding:10px 15px; border-radius:8px; border:none; background:#3498db; color:white; }
  #hud { position:absolute; top:10px; left:50%; transform:translateX(-50%); color:white; font-size:18px; font-family:sans-serif; }
</style>
</head>
<body>

<div id="hud">Level: 1 | Checkpoint: 1</div>
<div class="controls">
  <button id="left">⬅️</button>
  <button id="jump">⬆️</button>
  <button id="right">➡️</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let player, platforms = [], checkpoints = [];
let move = { left:false, right:false, jump:false };
let velocity = new THREE.Vector3();
let canJump = false;
let gravity = 0.008, speed = 0.08, jumpPower = 0.18;
let level = 1, checkpoint = 0;
let movingPlatforms = [];

init();
animate();

// --- Initialization ---
function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202033);

  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,6,10);
  camera.lookAt(0,0,0);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lights
  const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
  light.position.set(0,20,0);
  scene.add(light);

  // Ground
  addPlatform(0, -0.5, 0, 50, 1, 50, 0x2c3e50, false);

  // Player
  const playerGeo = new THREE.SphereGeometry(0.5,16,16);
  const playerMat = new THREE.MeshStandardMaterial({color:0xe74c3c});
  player = new THREE.Mesh(playerGeo, playerMat);
  player.position.set(0,0.5,0);
  scene.add(player);

  setupControls();
  loadLevel(level);

  window.addEventListener('resize', onResize);
}

// --- Utility ---
function addPlatform(x,y,z,w=3,h=0.5,d=3,color=0x3498db, isMoving=false, moveRange=2, speed=0.02){
  const geo = new THREE.BoxGeometry(w,h,d);
  const mat = new THREE.MeshStandardMaterial({color});
  const plat = new THREE.Mesh(geo, mat);
  plat.position.set(x,y+d/2,z);
  plat.userData = { isMoving, moveDir:1, moveRange, speed, startX:x };
  scene.add(plat);
  platforms.push(plat);
  if(isMoving) movingPlatforms.push(plat);
  return plat;
}

function addCheckpoint(x,y,z){
  const geo = new THREE.BoxGeometry(1,1,1);
  const mat = new THREE.MeshStandardMaterial({color:0x2ecc71});
  const cp = new THREE.Mesh(geo, mat);
  cp.position.set(x,y+0.5,z);
  scene.add(cp);
  checkpoints.push(cp);
}

// --- Controls ---
function setupControls(){
  document.getElementById('left').addEventListener('touchstart', e => move.left=true);
  document.getElementById('left').addEventListener('touchend', e => move.left=false);

  document.getElementById('right').addEventListener('touchstart', e => move.right=true);
  document.getElementById('right').addEventListener('touchend', e => move.right=false);

  document.getElementById('jump').addEventListener('touchstart', e => {
    if(canJump){
      velocity.y = jumpPower;
      canJump = false;
    }
  });
}

function onResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// --- Level system ---
function loadLevel(num){
  // Remove old platforms except ground
  platforms.forEach(p => { if(!p.userData.isGround) scene.remove(p); });
  platforms = platforms.filter(p => p.userData.isGround);
  checkpoints.forEach(cp => scene.remove(cp));
  checkpoints = [];
  movingPlatforms = [];
  checkpoint = 0;
  updateHUD();

  if(num===1){
    // Level 1: simple
    for(let i=0;i<6;i++){
      addPlatform(i*4 - 8, 0.25+i*1.2, -i*2);
      if(i===2 || i===5) addCheckpoint(i*4 - 8, 0.25+i*1.2, -i*2);
    }
  }
  if(num===2){
    // Level 2: moving platforms
    for(let i=0;i<8;i++){
      addPlatform(i*4 - 10, 0.25+Math.sin(i)*1.5, -i*2, 3,0.5,3, 0x3498db, i%2===0, 2, 0.03);
      if(i===3 || i===7) addCheckpoint(i*4 - 10, 0.25+Math.sin(i)*1.5, -i*2);
    }
  }
}

// --- HUD ---
function updateHUD(){
  document.getElementById('hud').textContent = `Level: ${level} | Checkpoint: ${checkpoint+1}`;
}

// --- Animate ---
function animate(){
  requestAnimationFrame(animate);

  // Move platforms
  movingPlatforms.forEach(plat => {
    plat.position.x += plat.userData.speed * plat.userData.moveDir;
    if(Math.abs(plat.position.x - plat.userData.startX) > plat.userData.moveRange){
      plat.userData.moveDir *= -1;
    }
  });

  // Gravity
  velocity.y -= gravity;
  player.position.y += velocity.y;

  // Horizontal movement
  if(move.left) player.position.x -= speed;
  if(move.right) player.position.x += speed;

  // Collision with platforms
  let onPlatform = false;
  platforms.forEach(plat => {
    const px = player.position.x;
    const py = player.position.y - 0.5;
    const pz = player.position.z;

    const left = plat.position.x - plat.scale.x/2;
    const right = plat.position.x + plat.scale.x/2;
    const top = plat.position.y + plat.scale.y/2;
    const bottom = plat.position.y - plat.scale.y/2;
    const front = plat.position.z - plat.scale.z/2;
    const back = plat.position.z + plat.scale.z/2;

    if(py >= bottom && py <= top && px >= left && px <= right && pz >= front && pz <= back && velocity.y <= 0){
      onPlatform = true;
      player.position.y = top + 0.5;
      velocity.y = 0;
      canJump = true;
    }
  });

  // Ground
  if(player.position.y <= 0.5){
    onPlatform = true;
    player.position.y = 0.5;
    velocity.y = 0;
    canJump = true;
  }

  // Check checkpoints
  checkpoints.forEach((cp, i) => {
    if(player.position.distanceTo(cp.position) < 1){
      checkpoint = i;
      updateHUD();
    }
  });

  // Fall reset
  if(player.position.y < -10){
    if(checkpoints[checkpoint]){
      player.position.copy(checkpoints[checkpoint].position);
      player.position.y += 1;
      velocity.set(0,0,0);
    } else {
      player.position.set(0,0.5,0);
      velocity.set(0,0,0);
    }
  }

  // Level completion
  if(checkpoint === checkpoints.length-1 && checkpoints.length>0){
    level++;
    loadLevel(level);
    player.position.set(0,0.5,0);
    velocity.set(0,0,0);
  }

  // Smooth camera follow
  camera.position.lerp(new THREE.Vector3(player.position.x, player.position.y+6, player.position.z+10), 0.1);
  camera.lookAt(player.position);

  renderer.render(scene, camera);
}
</script>
</body>
</html>
