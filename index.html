<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no">
<title>Mobile Obstacle Course</title>
<style>
  body, html { margin:0; padding:0; width:100%; height:100%; overflow:hidden; }
  canvas { display:block; }
  .controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display:flex; gap:10px; }
  .controls button { font-size:18px; padding:10px 15px; border-radius:8px; border:none; background:#3498db; color:white; }
</style>
</head>
<body>

<div class="controls">
  <button id="left">⬅️</button>
  <button id="jump">⬆️</button>
  <button id="right">➡️</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let player, platforms = [];
let moveLeft = false, moveRight = false, jump = false;
let velocity = new THREE.Vector3();
let canJump = false;

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202033);

  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 6, 10);
  camera.lookAt(0, 0, 0);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lights
  const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
  light.position.set(0,20,0);
  scene.add(light);

  // Ground
  const groundGeo = new THREE.BoxGeometry(50,1,50);
  const groundMat = new THREE.MeshStandardMaterial({color:0x2c3e50});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.position.y = -0.5;
  scene.add(ground);

  // Player
  const playerGeo = new THREE.SphereGeometry(0.5,16,16);
  const playerMat = new THREE.MeshStandardMaterial({color:0xe74c3c});
  player = new THREE.Mesh(playerGeo, playerMat);
  player.position.set(0,0.5,0);
  scene.add(player);

  // Platforms
  const platMat = new THREE.MeshStandardMaterial({color:0x3498db});
  for(let i=0; i<5; i++){
    const platGeo = new THREE.BoxGeometry(3,0.5,3);
    const plat = new THREE.Mesh(platGeo, platMat);
    plat.position.set(i*4 - 8, 0.25 + i*1.2, -i*2);
    scene.add(plat);
    platforms.push(plat);
  }

  // Touch buttons
  document.getElementById('left').addEventListener('touchstart',()=>moveLeft=true);
  document.getElementById('left').addEventListener('touchend',()=>moveLeft=false);
  document.getElementById('right').addEventListener('touchstart',()=>moveRight=true);
  document.getElementById('right').addEventListener('touchend',()=>moveRight=false);
  document.getElementById('jump').addEventListener('touchstart',()=>{ if(canJump){velocity.y = 0.15; canJump=false; } });

  window.addEventListener('resize', ()=> {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function animate(){
  requestAnimationFrame(animate);

  // Simple physics
  velocity.y -= 0.008; // gravity
  player.position.y += velocity.y;

  // Horizontal movement
  if(moveLeft) player.position.x -= 0.08;
  if(moveRight) player.position.x += 0.08;

  // Ground collision
  let onPlatform = false;
  for(let plat of platforms){
    if(player.position.y - 0.5 <= plat.position.y + 0.25 &&
       player.position.y - 0.5 >= plat.position.y &&
       player.position.x > plat.position.x - 1.5 &&
       player.position.x < plat.position.x + 1.5 &&
       player.position.z > plat.position.z - 1.5 &&
       player.position.z < plat.position.z + 1.5
    ){
      onPlatform = true;
      player.position.y = plat.position.y + 0.5;
      velocity.y = 0;
      canJump = true;
    }
  }
  if(player.position.y <= 0.5){ // ground
    onPlatform = true;
    player.position.y = 0.5;
    velocity.y = 0;
    canJump = true;
  }

  // Camera follows
  camera.position.x = player.position.x;
  camera.position.z = player.position.z + 10;
  camera.position.y = player.position.y + 6;
  camera.lookAt(player.position);

  renderer.render(scene, camera);
}
</script>

</body>
</html>
