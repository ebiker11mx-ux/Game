<script>
(() => {
  /* -------------------- BASIC SETUP -------------------- */
  const canvas = document.getElementById('canvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setPixelRatio(Math.min(1.75, window.devicePixelRatio || 1));
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0e18);
  scene.fog = new THREE.Fog(0x0b0e18, 36, 160);

  const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);

  /* -------------------- LIGHTS -------------------- */
  scene.add(new THREE.HemisphereLight(0xaec9ff, 0x162040, 0.95));
  const dir = new THREE.DirectionalLight(0xffffff, 0.65);
  dir.position.set(7,10,5);
  scene.add(dir);

  /* -------------------- MATERIALS -------------------- */
  const matPlatform = new THREE.MeshStandardMaterial({ color:0x3a66ff });
  const matStart    = new THREE.MeshStandardMaterial({ color:0x28c76f });
  const matGoal     = new THREE.MeshStandardMaterial({ color:0xffb636, emissive:0x422000, emissiveIntensity:.15 });
  const matHazard   = new THREE.MeshStandardMaterial({ color:0xff4d4f });
  const matCoin     = new THREE.MeshStandardMaterial({ color:0xffe000, metalness:.6, roughness:.3 });
  const matPlayer   = new THREE.MeshStandardMaterial({ color:0xd0e3ff });

  /* -------------------- PLAYER -------------------- */
  const playerSize = 0.62;
  const player = new THREE.Mesh(
    new THREE.BoxGeometry(playerSize, playerSize, playerSize),
    matPlayer
  );
  scene.add(player);

  const followPivot = new THREE.Object3D();
  scene.add(followPivot);

  /* -------------------- HUD -------------------- */
  const elLevel = document.getElementById('level');
  const elCoins = document.getElementById('coins');
  const elCoinsTotal = document.getElementById('coinsTotal');
  const elBest = document.getElementById('best');
  const elTime = document.getElementById('time');

  /* -------------------- CONTROLS -------------------- */
  let stickVec = { x:0, y:0 };
  let jumpPressed = false;

  const stick = document.getElementById('stick');
  const knob = document.getElementById('knob');

  function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }

  stick.addEventListener('pointermove', e => {
    if (!e.buttons) return;
    const r = stick.getBoundingClientRect();
    const dx = e.clientX - (r.left + r.width/2);
    const dy = e.clientY - (r.top + r.height/2);
    const max = r.width * 0.22;
    const len = Math.hypot(dx,dy);
    const s = len > max ? max/len : 1;
    knob.style.transform = `translate(${dx*s}px,${dy*s}px)`;
    stickVec.x = clamp((dx*s)/max,-1,1);
    stickVec.y = clamp((dy*s)/max,-1,1);
  });

  stick.addEventListener('pointerup', () => {
    knob.style.transform = 'translate(-50%,-50%)';
    stickVec.x = stickVec.y = 0;
  });

  document.getElementById('jumpBtn').onpointerdown = () => jumpPressed = true;
  document.getElementById('jumpBtn').onpointerup   = () => jumpPressed = false;

  /* -------------------- PHYSICS -------------------- */
  const vel = new THREE.Vector3();
  const GRAVITY = -14;
  const JUMP = 7.8;
  let onGround = false;

  /* -------------------- COURSE -------------------- */
  const course = new THREE.Group();
  scene.add(course);
  const colliders = [];
  const coins = [];
  let coinsCollected = 0;

  function addCollider(mesh,type){
    colliders.push({ mesh, type, box:new THREE.Box3().setFromObject(mesh) });
  }

  function platform(x,y,z,w=3,d=3,mat=matPlatform){
    const m = new THREE.Mesh(new THREE.BoxGeometry(w,.32,d),mat);
    m.position.set(x,y,z);
    course.add(m);
    addCollider(m,'platform');
    return m;
  }

  function coin(x,y,z){
    const c = new THREE.Mesh(new THREE.CylinderGeometry(.35,.35,.08,24),matCoin);
    c.position.set(x,y,z);
    course.add(c);
    addCollider(c,'coin');
    coins.push(c);
  }

  function goal(x,y,z){
    const g = platform(x,y,z,4,4,matGoal);
    g.userData.goal = true;
  }

  /* -------------------- LEVELS -------------------- */
  const levels = [
    () => {
      platform(0,2,0,4,4,matStart);
      platform(4,3,-6);
      coin(4,5,-6);
      goal(8,4,-12);
    },
    () => {
      platform(0,3,0,4,4,matStart);
      platform(3,4,-6);
      platform(6,5,-10);
      coin(3,6,-6);
      coin(6,7,-10);
      goal(10,6,-14);
    }
  ];

  let levelIndex = 0;
  let levelStart = 0;
  const bestTimes = {};

  function loadLevel(i){
    course.clear();
    colliders.length = coins.length = 0;
    coinsCollected = 0;

    levels[i]();
    player.position.set(0,5,0);
    vel.set(0,0,0);
    levelStart = performance.now();

    elLevel.textContent = i+1;
    elCoins.textContent = 0;
    elCoinsTotal.textContent = coins.length;
  }

  function restartLevel(){ loadLevel(levelIndex); }

  document.getElementById('restart').onclick = restartLevel;

  /* -------------------- GAME LOOP -------------------- */
  function animate(t){
    requestAnimationFrame(animate);
    const dt = 0.016;

    vel.x += stickVec.x * 7 * dt;
    vel.z += -stickVec.y * 7 * dt;
    vel.y += GRAVITY * dt;

    if (jumpPressed && onGround){
      vel.y = JUMP;
      onGround = false;
    }

    player.position.addScaledVector(vel,dt);

    onGround = false;
    const pBox = new THREE.Box3().setFromCenterAndSize(
      player.position,
      new THREE.Vector3(playerSize,playerSize,playerSize)
    );

    for (const c of colliders){
      c.box.setFromObject(c.mesh);

      if (pBox.intersectsBox(c.box)){
        if (c.type === 'platform'){
          player.position.y = c.box.max.y + playerSize/2;
          vel.y = 0;
          onGround = true;
        }
        if (c.type === 'coin'){
          course.remove(c.mesh);
          colliders.splice(colliders.indexOf(c),1);
          coinsCollected++;
          elCoins.textContent = coinsCollected;
        }
        if (c.mesh.userData.goal){
          const time = (performance.now()-levelStart)/1000;
          bestTimes[levelIndex] = Math.min(bestTimes[levelIndex]||999,time);
          levelIndex = (levelIndex+1)%levels.length;
          loadLevel(levelIndex);
          return;
        }
      }
    }

    followPivot.position.lerp(player.position,0.15);
    camera.position.lerp(
      new THREE.Vector3(
        followPivot.position.x-5,
        followPivot.position.y+4,
        followPivot.position.z+8
      ),0.1
    );
    camera.lookAt(followPivot.position);

    elTime.textContent = ((performance.now()-levelStart)/1000).toFixed(1)+"s";
    elBest.textContent = bestTimes[levelIndex]?.toFixed(1)+"s" ?? "â€”";

    renderer.render(scene,camera);
  }

  /* -------------------- RESIZE -------------------- */
  window.addEventListener('resize',()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
  });

  /* -------------------- START -------------------- */
  loadLevel(0);
  animate();

})();
</script>
