<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Mini Obby Runner</title>
  <style>
    :root {
      --bg: #0e1220;
      --fg: #e8ecf1;
      --accent: #66e3ff;
      --coin: #ffd84d;
      --danger: #ff6b6b;
      --ground: #1b2439;
      --ui: rgba(0,0,0,0.35);
    }
    html, body {
      margin: 0; height: 100%; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, sans-serif;
    }
    #game {
      display: grid; place-items: center; height: 100vh; width: 100vw; touch-action: none;
    }
    canvas {
      background: linear-gradient(180deg, #0e1220 0%, #0e1220 60%, #11182b 60%, #11182b 100%);
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      border-radius: 12px;
    }
    #hud {
      position: absolute; inset: 0; pointer-events: none; display: grid; grid-template-rows: auto 1fr auto;
      padding: 12px; gap: 8px;
    }
    .bar {
      display: flex; gap: 8px; align-items: center; justify-content: space-between;
    }
    .pill {
      background: var(--ui); color: var(--fg); padding: 8px 12px; border-radius: 999px; backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }
    #controls {
      pointer-events: auto; display: grid; grid-template-columns: 1fr 1fr; gap: 12px;
    }
    .btn {
      background: var(--ui); color: var(--fg); padding: 14px; border-radius: 12px; text-align: center; user-select: none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }
    .btn:active { transform: scale(0.98); }
    #centerBanner {
      pointer-events: none; display: grid; place-items: center;
    }
    .banner {
      background: var(--ui); padding: 14px 18px; border-radius: 12px; text-align: center; max-width: 70%;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }
    a { color: var(--accent); text-decoration: none; }
    #brand {
      font-size: 12px; opacity: 0.8;
    }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="c" width="420" height="700"></canvas>
    <div id="hud">
      <div class="bar">
        <div class="pill">Score: <span id="score">0</span></div>
        <div class="pill">Coins: <span id="coins">0</span></div>
      </div>
      <div id="centerBanner">
        <div class="banner" id="banner">Tap to start. Hold left/right to move. Tap jump.</div>
      </div>
      <div class="bar">
        <div id="brand" class="pill">Mini Obby Runner • v1.0</div>
        <div id="controls">
          <div class="btn" id="left">◀ Move</div>
          <div class="btn" id="right">Move ▶</div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const coinsEl = document.getElementById('coins');
  const bannerEl = document.getElementById('banner');
  const leftBtn = document.getElementById('left');
  const rightBtn = document.getElementById('right');

  // Responsive canvas
  function fit() {
    const w = Math.min(window.innerWidth, 480);
    const h = Math.min(window.innerHeight, 840);
    const scale = Math.min(w / canvas.width, h / canvas.height);
    canvas.style.transform = `scale(${scale})`;
  }
  window.addEventListener('resize', fit);
  fit();

  // Game state
  const W = canvas.width, H = canvas.height;
  const GRAV = 0.9, FRICTION = 0.86, MOVE = 0.75, JUMP = 17;
  const groundY = H - 120;

  let running = false;
  let score = 0;
  let coins = 0;
  let tick = 0;

  const player = {
    x: W/2, y: groundY - 40, w: 36, h: 36,
    vx: 0, vy: 0,
    onGround: true,
    jumpQueued: false,
    color: '#9be7ff'
  };

  const inputs = { left: false, right: false, jump: false };
  const obstacles = [];
  const pickups = [];
  const particles = [];

  // Helpers
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rectsOverlap = (a,b) => (a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y);

  function spawnObstacle() {
    const width = 40 + Math.random()*60;
    const height = 20 + Math.random()*40;
    const gapY = groundY - (40 + Math.random()*220);
    obstacles.push({ x: W + 40, y: gapY, w: width, h: height, color: '#ff6b6b' });
  }

  function spawnCoin() {
    const r = 16;
    const x = W + 60;
    const y = groundY - (80 + Math.random()*260);
    pickups.push({ x, y, w: r, h: r, type: 'coin' });
  }

  function sparkle(x, y, color = '#ffffff') {
    for (let i=0; i<10; i++) {
      const a = Math.random() * Math.PI * 2;
      const s = 1 + Math.random()*2;
      particles.push({
        x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life: 24 + Math.random()*18, color, size: 2 + Math.random()*2
      });
    }
  }

  // Input handling
  function start() {
    if (!running) {
      running = true;
      bannerEl.textContent = '';
    }
  }
  canvas.addEventListener('pointerdown', (e) => {
    start();
    const cx = e.offsetX;
    inputs.jump = true;
    if (cx < W/2) inputs.left = true; else inputs.right = true;
  });
  canvas.addEventListener('pointerup', () => {
    inputs.left = false; inputs.right = false; inputs.jump = false;
  });
  // Buttons for consistent mobile UX
  leftBtn.addEventListener('pointerdown', () => { start(); inputs.left = true; });
  leftBtn.addEventListener('pointerup', () => { inputs.left = false; });
  rightBtn.addEventListener('pointerdown', () => { start(); inputs.right = true; });
  rightBtn.addEventListener('pointerup', () => { inputs.right = false; });
  canvas.addEventListener('dblclick', () => { inputs.jump = true; setTimeout(()=>inputs.jump=false, 60); });

  // Keyboard too
  window.addEventListener('keydown', (e) => {
    start();
    if (e.key === 'ArrowLeft' || e.key === 'a') inputs.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') inputs.right = true;
    if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') inputs.jump = true;
  });
  window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a') inputs.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') inputs.right = false;
    if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w') inputs.jump = false;
  });

  // Game loop
  function update() {
    tick++;
    if (!running) { draw(); requestAnimationFrame(update); return; }

    // Difficulty and spawn pacing
    const speed = 4 + Math.min(8, Math.floor(tick / 600)); // ramps with time
    if (tick % 70 === 0) spawnObstacle();
    if (tick % 120 === 0) spawnCoin();

    // Player physics
    if (inputs.left) player.vx -= MOVE;
    if (inputs.right) player.vx += MOVE;
    player.vx *= FRICTION;
    player.vx = clamp(player.vx, -6, 6);
    player.x += player.vx;

    // Jump buffer
    if (inputs.jump) player.jumpQueued = true;
    if (player.onGround && player.jumpQueued) {
      player.vy = -JUMP;
      player.onGround = false;
      player.jumpQueued = false;
      sparkle(player.x + player.w/2, player.y + player.h, '#66e3ff');
    }

    // Gravity
    player.vy += GRAV;
    player.y += player.vy;

    // Ground clamp
    if (player.y + player.h >= groundY) {
      player.y = groundY - player.h;
      player.vy = 0;
      player.onGround = true;
    }

    // Walls
    player.x = clamp(player.x, 8, W - player.w - 8);

    // Obstacles movement
    for (let i=obstacles.length-1; i>=0; i--) {
      const o = obstacles[i];
      o.x -= speed;
      if (o.x + o.w < -40) obstacles.splice(i,1);
      // Collision
      if (rectsOverlap(player, o)) {
        // Hit = score penalty + spark
        score = Math.max(0, score - 10);
        sparkle(player.x + player.w/2, player.y + player.h/2, '#ff6b6b');
        // knockback
        player.vx += (player.x < o.x ? -6 : 6);
        player.vy = -8;
      }
    }

    // Pickups
    for (let i=pickups.length-1; i>=0; i--) {
      const p = pickups[i];
      p.x -= speed;
      if (p.x + p.w < -40) pickups.splice(i,1);
      if (rectsOverlap(player, {x:p.x, y:p.y, w:p.w, h:p.h})) {
        if (p.type === 'coin') {
          coins += 1;
          score += 25;
          sparkle(p.x + p.w/2, p.y + p.h/2, '#ffd84d');
        }
        pickups.splice(i,1);
      }
    }

    // Particles
    for (let i=particles.length-1; i>=0; i--) {
      const p = particles[i];
      p.x += p.vx; p.y += p.vy; p.life -= 1;
      p.vy += 0.05;
      if (p.life <= 0) particles.splice(i,1);
    }

    // Scoring over time
    score += 1;

    draw();
    requestAnimationFrame(update);
  }

  function drawGround() {
    ctx.fillStyle = '#1b2439';
    ctx.fillRect(0, groundY, W, H - groundY);
    // lanes
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#1f2a45';
    for (let i=0;i<3;i++) {
      const y = groundY + 12 + i*18;
      ctx.fillRect(0, y, W, 6);
    }
    ctx.globalAlpha = 1;
  }

  function drawPlayer() {
    // body
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.w, player.h);
    // face
    ctx.fillStyle = '#092a3a';
    ctx.fillRect(player.x + 8, player.y + 10, 6, 6);
    ctx.fillRect(player.x + 22, player.y + 10, 6, 6);
    ctx.fillRect(player.x + 12, player.y + 22, 12, 4);
    // glow
    ctx.globalAlpha = 0.07;
    ctx.fillStyle = '#9be7ff';
    ctx.fillRect(player.x-4, player.y-4, player.w+8, player.h+8);
    ctx.globalAlpha = 1;
  }

  function drawObstacles() {
    obstacles.forEach(o => {
      ctx.fillStyle = o.color;
      ctx.fillRect(o.x, o.y, o.w, o.h);
      // spikes top
      ctx.fillStyle = '#ff8a8a';
      for (let i=0;i<o.w;i+=8) {
        ctx.beginPath();
        ctx.moveTo(o.x+i, o.y);
        ctx.lineTo(o.x+i+4, o.y-8);
        ctx.lineTo(o.x+i+8, o.y);
        ctx.closePath();
        ctx.fill();
      }
    });
  }

  function drawCoins() {
    pickups.forEach(p => {
      if (p.type === 'coin') {
        ctx.save();
        ctx.translate(p.x + p.w/2, p.y + p.h/2);
        ctx.rotate(((tick % 360)/360) * Math.PI*2);
        ctx.fillStyle = '#ffd84d';
        ctx.beginPath();
        ctx.arc(0,0,p.w,0,Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#eabf39';
        ctx.fillRect(-p.w/2, -2, p.w, 4);
        ctx.restore();
      }
    });
  }

  function drawParticles() {
    particles.forEach(p => {
      ctx.globalAlpha = Math.max(0, p.life / 42);
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    ctx.globalAlpha = 1;
  }

  function drawSky() {
    // parallax bars
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = '#66e3ff';
    for (let i=0;i<6;i++) {
      const w = 80 + i*25;
      const x = (W - ((tick*0.5) % (W + w))) - w;
      const y = 80 + i*50;
      ctx.fillRect(x, y, w, 6);
    }
    ctx.globalAlpha = 1;
  }

  function draw() {
    ctx.clearRect(0,0,W,H);
    drawSky();
    drawGround();
    drawObstacles();
    drawCoins();
    drawPlayer();
    drawParticles();

    scoreEl.textContent = score;
    coinsEl.textContent = coins;
  }

  update();

  // Restart on tap after death or pause (simple pause toggle)
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      running = false;
      bannerEl.textContent = 'Paused. Tap to resume.';
    } else {
      // resume on next start input
    }
  });
})();
</script>
</body>
</html>
